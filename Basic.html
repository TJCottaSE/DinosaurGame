<!-- 
    Built by: T.J. Cotta
    Contact: TJCottaSE@gmail.com
-->
<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0" charset="utf-8"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    
    position: absolute;
    top: 5px;
    left: 5px;
}
button {
    position: relative;
    margin-top: 300px;
}
</style>
</head>
<body onload="myGameArea.init()">
    <br>
    <div id="start">
        <button onclick="startGame()">Start Game</button>
    </div>


<script>

var myGamePiece;
var myObstacles = [];
var myGround = [];
var myScore;
var myRound = 1;
var centeredButton;
var leftPressed = false;
var rightPressed = false;
var useRandY = false;  // Randomizes the y-coord for incoming meteors; Default = 0;
var lastDirectionPressed;
var jumpTime = 12; // This variable controls the number of frames that pass before gravity begins to pull down on the game piece

const canvasHeight = 810; // Needs to be dynamically sized
const canvasWidth = 1440; // Needs to be dynamically sized
const roundDuration = 2000; // Controls the length of each stage based on number of frames traversed to the right
var GamePieceWidth = canvasWidth/16;
var GamePieceHeight = canvasHeight/9;
var ObstacleWidth = canvasWidth/16;
var ObstacleHeight = canvasHeight/9;

// Change jump duration based on screen height
if (canvasHeight < 300){
    jumpTime = 6;
}
else if (canvasHeight < 600) {
    jumpTime = 8;
}
else if (canvasHeight < 900) {
    jumpTime = 10;
}

function startGame() {
    myGamePiece = new component(GamePieceWidth, GamePieceHeight, "assets/Dino-2-flipped.png", canvasWidth/2, canvasHeight-25, "image", "assets/Dino-2.png");
    myGamePiece.gravity = 0.05;
    myScore = new component("30px", "Consolas", "white", 10, 30, "text");
    document.getElementById("start").innerHTML = "<button onclick=\"accelerate(-0.5)\">Jump</button>";
    myGameArea.start();
}

var myGameArea = {
    backgroundCanvas : document.createElement("canvas"),
    canvas : document.createElement("canvas"),
    init : function() {
        // Draws the background canvas below the play canvas
        this.backgroundCanvas.width = canvasWidth;
        this.backgroundCanvas.height = canvasHeight;
        var ctx2 = this.backgroundCanvas.getContext("2d");
        var backgroundCanvas2 = this.backgroundCanvas;
        this.context2 = ctx2;
        var background = new Image();
        background.onload = function() {
            ctx2.drawImage(background, 0, 0, canvasWidth, canvasHeight);
            document.body.insertBefore(backgroundCanvas2, document.body.childNodes[0]);
        }
        background.src = "assets/bg.jpg";

        // Draws the play canvas
        this.canvas.width = canvasWidth;
        this.canvas.height = canvasHeight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[1]);
        this.frameNo = 0;
        this.frameCount = 0;
    },
    start : function() {
        // Every 10 ms update the game area
        this.interval = setInterval(updateGameArea, 10);
        //this.interval2 = setInterval(updateBackground, 10);
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, color, x, y, type, altImage) {
    this.type = type;
    if (type == "image") {
        this.image = new Image();
        this.image.src = color;
    }
    this.altImageSrc = altImage;
    this.score = 0;
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;    
    this.x = x;
    this.y = y;
    this.gravity = 0;
    this.gravitySpeed = 0;
    this.frameInitJump = 0;
    // Draws the image
    this.update = function() {
        ctx = myGameArea.context;
        if (this.type == "text") {
            ctx.font = this.width + " " + this.height;
            ctx.fillStyle = color;
            ctx.fillText(this.text, this.x, this.y);
        } else if (type == "image") {
            ctx.drawImage(this.image, 
                this.x, 
                this.y,
                this.width, this.height);
        } else {
            ctx.fillStyle = color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }
    // Changes the image's location
    this.newPos = function() {
        if (myGameArea.frameCount - this.frameInitJump > jumpTime) {this.gravity = 0.05}
        this.gravitySpeed += this.gravity;
        this.x += this.speedX;
        this.y += this.speedY + this.gravitySpeed;
        this.hitBottom();
    }
    // Stops the game piece at "ground level"
    this.hitBottom = function() {
        var rockbottom = myGameArea.canvas.height - this.height - 20;
        if (this.y > rockbottom) {
            this.y = rockbottom;
            this.gravitySpeed = 0;
        }
    }
    // Controls the crash into object mechanism
    this.crashWith = function(otherobj) {
        var myleft = this.x;
        var myright = this.x + (this.width);
        var mytop = this.y;
        var mybottom = this.y + (this.height);
        var otherleft = otherobj.x;
        var otherright = otherobj.x + (otherobj.width);
        var othertop = otherobj.y;
        var otherbottom = otherobj.y + (otherobj.height);
        var crash = true;
        if ( (mybottom < (othertop + (canvasHeight/32))) || // Allow for visual overlap before crashing
             (mytop > (otherbottom - (canvasHeight/64))) || 
             (myright < (otherleft + (canvasWidth/96))) || 
             (myleft > (otherright - (canvasWidth/96))) ){

                crash = false;
        }
        return crash;
    }
}

function updateBackground() {
    
    var cycleNum = Math.floor(myGameArea.frameCount / 10) % 6;
    console.log("myGameArea.frameCount/10 = " + myGameArea.frameCount/10);
    console.log("cycleNum = " + cycleNum);
    background = new Image();
    switch (cycleNum){
        case 0:
            background.src = "assets/bg1.jpg";
            break;
        case 1:
            background.src = "assets/bg2.jpg";
            break;
        case 2:
            background.src = "assets/bg3.jpg";
            break;
        case 3:
            background.src = "assets/bg4.jpg";
            break;
        case 4:
            background.src = "assets/bg5.jpg";
            break;
        case 5:
            background.src = "assets/bg6.jpg";
            break;
    }

    myGameArea.context2.drawImage(background, 0, 0, canvasWidth, canvasHeight);

}

function updateGameArea() {
    var x, y, minHeight, maxHeight, randX;
    for (i = 0; i < myObstacles.length; i += 1) {
        if (myGamePiece.crashWith(myObstacles[i])) {
            // Show Game Over message
            console.log("Game Over!!!!!!");
            // End
            return;
        } else if (myGameArea.frameNo % roundDuration == 0){
            // Advance to next level
            myRound = (myGameArea.frameNo / roundDuration) + 1;
        }
    }

    myGameArea.clear();
    document.onkeydown = checkKey;
    myGameArea.frameCount += 1;

    if (leftPressed){
        myGameArea.frameNo += -1;
    }
    if (rightPressed){
        myGameArea.frameNo += 1;
    }
    
    /* Consider possible changing the interval as well as the number of meteors on round change
     * to better facilitate difficulty levels.
     */
    if (frameInterval(200)) { 
        x = myGameArea.canvas.width;
        y = myGameArea.canvas.height;
        


        myGround.push(new component(50, 20, "assets/g1.png", x, y - 20, "image"));        // Temp Ground *Needs to be updated with non-copywright images (in Progress)*
        myGround.push(new component(50, 20, "assets/g2.png", x+50, y - 20, "image"));
        myGround.push(new component(50, 20, "assets/g1.png", x+100, y - 20, "image"));
        myGround.push(new component(50, 20, "assets/g2.png", x+150, y - 20, "image"));
    }

    if (timeInterval(200)) {
        if (myGameArea.frameNo != 0){
            for (i = 0; i < myRound; i++){
                /* Two times the width of a meteor obstacle, added to the canvas width
                 * to allow the meteor's starting x position to occur outside the view
                 *     mwCANVASmw
                 */
                randX = Math.floor(Math.random()*canvasWidth+ObstacleWidth);
                if (useRandY){
                    randY = Math.floor(Math.random()*(-1)*ObstacleHeight-ObstacleHeight);
                } else {
                    randY = (-1)*(ObstacleHeight);
                }
                // consider using randY for more difficulty
                myObstacles.push(new component(50, 150, "assets/Meteor.png", randX, randY, "image", "assets/Meteor-flipped.png"));
            }
        }
    }

    // Moves Obstacles 
    for (i = 0; i < myObstacles.length; i += 1) {
        if (leftPressed){
            myObstacles[i].x += 1;
        }
        if (rightPressed){
            myObstacles[i].x += -1;
        }

        // Obstacles continue to fall
        myObstacles[i].y += +1;

        // Flip the image to create spiraling effect
        if (myObstacles[i].y % 15 == 0){
            var temp = myObstacles[i].image.src;
            myObstacles[i].image = new Image();
            myObstacles[i].image.src = myObstacles[i].altImageSrc;
            myObstacles[i].altImageSrc = temp;
        }
        
        // Meteor disappear after rock crosses ground
        if ( (myObstacles[i].y + myObstacles[i].height - 20) > myGameArea.canvas.height) {
            //console.log("I got called");
            myObstacles[i].y = myGameArea.canvas.height + myObstacles[i].height;
        }
        myObstacles[i].update();                                    
    }
    // Moves ground left to right
    for (i = 0; i < myGround.length; i++) {
        if (leftPressed){
            myGround[i].x += 1;
        }
        if (rightPressed){
            myGround[i].x += -1;
        }
        myGround[i].update();
    }
    
    myScore.text="SCORE: " + myGameArea.frameNo;
    myScore.update();
    myGamePiece.newPos();
    myGamePiece.update();
}

function frameInterval(n) {
    if ((myGameArea.frameNo / n) % 1 == 0) {return true;}
    return false;
}

function timeInterval(n) {
    if ((myGameArea.frameCount / n) % 1 == 0) {return true;}
    return false;
}

function accelerate(n) {
    // Disallows double jumping
    if (myGamePiece.y == myGameArea.canvas.height - myGamePiece.height - 20){
        myGamePiece.gravity = n;
        myGamePiece.frameInitJump = myGameArea.frameCount;
    }
}

function checkKey(e){
    e = e || window.event;
    console.log("Key code received = " + e.keyCode);
    if (e.keyCode == '38' || e.keyCode == '32' || e.keyCode == '87'){  // JUMP!!
        // Up arrow || space bar || 'w' pressed
        accelerate(-0.5);
    }
    else if (e.keyCode == '40' || e.keyCode == '83'){ // Stop Moving, Stand Still
        // down arrow || 's' pressed
        leftPressed = false;
        rightPressed = false;
    }
    else if (e.keyCode == '37' || e.keyCode == '65'){ // Move character left
        // left arrow or 'a' pressed
        leftPressed = true;
        rightPressed = false;
        if (!myGamePiece.image.src.includes("flipped")){
            flipCharImage();
        }
    }
    else if (e.keyCode == '39' || e.keyCode == '68'){ // Move character right
        // right arrow  or 'd' pressed
        rightPressed = true;
        leftPressed = false;
        if (myGamePiece.image.src.includes("flipped")){
            flipCharImage();
        }
    }
}

function flipCharImage(){
    var temp = myGamePiece.image.src;
    myGamePiece.image = new Image();
    myGamePiece.image.src = myGamePiece.altImageSrc;
    myGamePiece.altImageSrc = temp;
}
</script>

<br>

<p>Jump over the obstacles. How long can you stay alive?</p>
<h2>Controls</h2>
<p>
    Move Right: d, right arrow<br>
    Move Left: a, left arrow<br>
    Jump: w, up arrow, space bar<br>
    Stop: s, down arrow<br>
</p>

</body>
</html>